package #! .Name !#

// Code generated by wrapgen DO NOT EDIT

import (
	#! range .Imports !##! .Package !# "#! .Path !#"
	#! end !#
)

#! $pkgName := .Source.Package !#
#! range .Interfaces !#
type Wraps#! .Name !# struct {
	wrapped #! .SrcType !#
}

#! $ifaceRef := . !##! range .Methods !#
#! $methodRef := . !#
func (w *Wraps#! $ifaceRef.Name !#) #! .Name !#(#! range $x, $e := .In !##! $e.Name !# #! $e.Type !##! if ne $x (add (len $methodRef.In) -1)!#, #! end !##! end !#) (#! $methodRef := . !##! range $x, $e := .Out !##! $e.Type !##! if ne $x (add (len $methodRef.Out) -1)!#, #! end !##! end !#) {
	start := time.Now()
    defer func(){
        log.Println("#! .Name !# latency:",time.Now().Since(start))
    }()
	#! if ne (len .Out) 0 !#var #! range $x, $e := .Out !##! $e.Name !##! if ne $x (add (len $methodRef.Out) -1) !#,#! end !##! end !# = #! end !#w.wrapped.#! .Name !#(#! range $x, $e := .In !##! $e.Name !##! if contains "..." $e.Type.String !#...#! end !##! if ne $x (add (len $methodRef.In ) -1) !#,#! end !##! end !#)
	return #! if ne (len .Out) 0 !##! range $x, $e := .Out !##! $e.Name !##! if ne $x (add (len $methodRef.Out) -1) !#,#! end !##! end !##! end !#
}
#! end !#
#! end !#